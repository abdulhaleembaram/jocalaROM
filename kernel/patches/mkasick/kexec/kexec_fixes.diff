From: Mike Kasick <mike@kasick.org>
Date: Tue, 18 Oct 2011 21:30:18 -0400

Enable kexec syscall and fix support for ARMv7.

Essentially a backport of the relevant functions from Linux 3.1-rc4.  In
particular, it now actually disables cache* and the MMU in preparation for
soft boot.  Without this, relocate_new_kernel() would hang for an unknown
reason.  Although, it's known that there's no safe way to execute that
function with the MMU on as it may overwrite active page tables.

The suggestion to call cpu_reset by its physical address comes from an
earlier kexec support patch by Will Deacon [1].  The arm_machine_restart()
modification is primarily to ensure setup_mm_for_reboot() is called before
cache is disabled, since setting the page table mappings takes a very long
time if done after.

* GB note: cpu_proc_fin already implements cache disabling, but is out of
sync with later Linuxes (i.e., it disables interrupts and flushes as well,
which is done earlier here).  This patch keeps cpu_proc_fin in sync with
EC05 patches and Linux 3.1-rc4.

[1] W. Deacon. [4/6] ARM: reset: add reset functionality for jumping to a
    physical address, Jun. 2011. https://patchwork.kernel.org/patch/852802/

diff --git a/kernel/arch/arm/configs/victory_8G_defconfig b/kernel/arch/arm/configs/victory_8G_defconfig
--- a/kernel/arch/arm/configs/victory_8G_defconfig
+++ b/kernel/arch/arm/configs/victory_8G_defconfig
@@ -433,7 +433,8 @@
 CONFIG_CMDLINE="console=ttySAC2,115200 init=/linuxrc"
 # CONFIG_CMDLINE_FORCE is not set
 # CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
 
 #
 # CPU Power Management
diff --git a/kernel/arch/arm/kernel/machine_kexec.c b/kernel/arch/arm/kernel/machine_kexec.c
--- a/kernel/arch/arm/kernel/machine_kexec.c
+++ b/kernel/arch/arm/kernel/machine_kexec.c
@@ -74,7 +74,16 @@
 			   (unsigned long) reboot_code_buffer + KEXEC_CONTROL_PAGE_SIZE);
 	printk(KERN_INFO "Bye!\n");
 
+	local_irq_disable();
+	local_fiq_disable();
+
+	setup_mm_for_reboot(0); /* mode is not used, so just pass 0*/
+
+	flush_cache_all();
 	cpu_proc_fin();
-	setup_mm_for_reboot(0); /* mode is not used, so just pass 0*/
-	cpu_reset(reboot_code_buffer_phys);
+	flush_cache_all();
+
+	/* Must call cpu_reset via physical address since ARMv7 (& v6) stalls the
+	 * pipeline after disabling the MMU. */
+	((typeof(cpu_reset) *)virt_to_phys(cpu_reset))(reboot_code_buffer_phys);
 }
diff --git a/kernel/arch/arm/kernel/process.c b/kernel/arch/arm/kernel/process.c
--- a/kernel/arch/arm/kernel/process.c
+++ b/kernel/arch/arm/kernel/process.c
@@ -29,6 +29,7 @@
 #include <linux/utsname.h>
 #include <linux/uaccess.h>
 
+#include <asm/cacheflush.h>
 #include <asm/leds.h>
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -89,10 +90,9 @@
 
 void arm_machine_restart(char mode, const char *cmd)
 {
-	/*
-	 * Clean and disable cache, and turn off interrupts
-	 */
-	cpu_proc_fin();
+	/* Disable interrupts first */
+	local_irq_disable();
+	local_fiq_disable();
 
 	/*
 	 * Tell the mm system that we are going to reboot -
@@ -101,13 +101,21 @@
 	 */
 	setup_mm_for_reboot(mode);
 
-#if 1
 #ifdef CONFIG_KERNEL_DEBUG_SEC
 	/* Clear the magic number because it's normal reboot */
 	kernel_sec_clear_upload_magic_number();
 #endif
+
+	/* Clean and invalidate caches */
+	flush_cache_all();
+
+	/* Turn off caching */
+	cpu_proc_fin();
+
+	/* Push out any further dirty data, and ensure cache is empty */
+	flush_cache_all();
+
 	writel(0x12345678, S5P_INFORM5);  /* Reset */
-#endif
 
 	/*
 	 * Now call the architecture specific reboot code.
diff --git a/kernel/arch/arm/mm/proc-v7.S b/kernel/arch/arm/mm/proc-v7.S
--- a/kernel/arch/arm/mm/proc-v7.S
+++ b/kernel/arch/arm/mm/proc-v7.S
@@ -45,14 +45,11 @@
 ENDPROC(cpu_v7_proc_init)
 
 ENTRY(cpu_v7_proc_fin)
-	stmfd	sp!, {lr}
-	cpsid	if				@ disable interrupts
-	bl	v7_flush_kern_cache_all
 	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
 	bic	r0, r0, #0x1000			@ ...i............
 	bic	r0, r0, #0x0006			@ .............ca.
 	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
-	ldmfd	sp!, {pc}
+	mov	pc, lr
 ENDPROC(cpu_v7_proc_fin)
 
 /*
@@ -63,9 +60,16 @@
  *	to what would be the reset vector.
  *
  *	- loc   - location to jump to for soft reset
+ *
+ *	This code must be executed using a flat identity mapping with
+ *      caches disabled.
  */
 	.align	5
 ENTRY(cpu_v7_reset)
+	mrc	p15, 0, r1, c1, c0, 0		@ ctrl register
+	bic	r1, r1, #0x1			@ ...............m
+	mcr	p15, 0, r1, c1, c0, 0		@ disable MMU
+	isb
 	mov	pc, r0
 ENDPROC(cpu_v7_reset)
 
